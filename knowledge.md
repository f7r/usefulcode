# __知识点__ #
## __数据结构__ ##
1. 链表
2. 栈
3. 队列
4. 树
## __算法__ ##
## __网络__ ##
### 1. TCP和UDP的区别 ###
(1) 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制  
(2) 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信  
(3) UDP 支持一对一、一对多、多对一和多对多的交互通信  
(4) 每一条 TCP 连接只能是点对点的  
(5) UDP 面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部  
(6) TCP 面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）  
### 2. TCP的三次握手 ###
(1) 首先接收方处于 LISTEN（监听）状态，等待客户的连接请求  
(2) 请求方向接收方发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x  
(3) 接收方收到连接请求报文，如果同意建立连接，则向请求方发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y  
(4) 请求方收到接收方的连接确认报文后，还要向接收方发出确认，确认号为 y+1，序号为 x+1  
(5) 接收方收到请求方的确认后，连接建立  
(6) 三次握手的原因：客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。  
### 3. TCP的四次挥手 ###
(1) 请求方发送连接释放报文，FIN=1，其序号为u（等于前面已经传送过来的数据的最后一个字节的序号加1）  
(2) 接收方收到之后发出确认，确认号为u+1，同时选择一个初始化的序号v，此时 TCP 属于半关闭状态，接收方能向请求方发送数据但是请求方不能向接收方发送数据  
(3) 当接收方不再需要连接时，发送连接释放报文，FIN=1，ACK=1，选择一个初始化的序号w，确认号为u+1  
(4) 请求方收到后发出确认，序号u+1，确认号为w+1，进入TIME-WAIT状态，等待 2 MSL（最大报文存活时间）后释放连接  
(5) 接收方收到请求方的确认后释放连接  
(6) 四次挥手的原因：客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文  
(7) TIME-WAIT：客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL 这么做有两个理由  
* 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生
* 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文
### 4. TCP特点 ###
(1) TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段  
(2) TCP 滑动窗口：发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。接收窗口只会对窗口内最后一个按序到达的字节进行确认，发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。  
(3) TCP 流量控制：流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。  
(4) TCP 拥塞控制：慢开始、拥塞避免、快重传、快恢复  
* 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，这里设窗口的大小单位为报文段
* 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...
* 设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1
* 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始
* 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认
* 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段
* 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免
* 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh
### 5. DNS ###
(1) DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输  
(2) 在两种情况下会使用 TCP 进行传输  
* 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）
* 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）
### 6. FTP ###
(1) 主动模式  
(2) 被动模式  
### 7. DHCP ###
(1) 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理  
(2) DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择  
(3) 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器  
(4) DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息  
### 8. Web 页面请求过程 ###
(1) DHCP配置客户端IP地址  
* 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中
* 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中
* 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备
* 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文
* DHCP ACK 报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码
* DHCP ACK 报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中
* 该帧的目的地址是请求主机的 MAC 地址，根据 MAC 地址表转发到主机对应的接口
* 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中配置默认网关
(2) ARP解析路由器的MAC地址  
* DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议
* 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器
* 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机
(3) DNS解析服务器的域名的IP地址  
* 主机向 DNS 服务器发送 DNS 查询报文
* 报文到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名
* 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机
(4) HTTP请求服务器的IP地址  
* 主机与服务器进行三次握手来建立连接
* 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器
* HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机
(5) 浏览器根据HTTP相应内容显示web页面
* 根据 HTML 的内容下载多个页面元素
* 页面元素可能位于多个服务器，则可能需要重新查询DNS和请求多个服务器上的资源
### 9. HTTP方法 ###
(1) GET：获取资源，当前网络请求中，绝大部分使用的是 GET 方法  
(2) HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分  
(3) POST：传输实体主体，POST 主要用来传输数据，而 GET 主要用来获取资源  
(4) PUT：上传资源实体，完全替代原始资源  
(5) PATCH： 对资源进行部分修改  
(6) DELETE：删除资源  
(7) OPTIONS：查询支持的方法  
(8) CONNECT：要求在与代理服务器通信时建立隧道  
(9) TRACE: 追踪路径  
### 10. HTTP状态码 ###
(1) 1XX：Informational（信息性状态码） 接收的请求正在处理  
(2) 2XX：Success（成功状态码） 请求正常处理完毕  
(3) 3XX：Redirection（重定向状态码） 需要进行附加操作以完成请求  
* 301 Moved Permanently：永久性重定向
* 302 Found：临时性重定向
(4) 4XX：Client Error（客户端错误状态码） 服务器无法处理请求  
(5) 5XX：Server Error（服务器错误状态码） 服务器处理请求出错  
* 500 Internal Server Error：服务器正在执行请求时发生错误
* 503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求
### 11. HTTP首部 ###
(1) 通用首部字段
(2) 请求首部字段
(3) 响应首部字段
(4) 实体首部字段
### 1. IPv6 ###
### 2. TCP/IP ###
### 3. HTTP ###
### 4. TLS ###
## __存储__ ##
1. Ceph
2. 文件系统
## __操作系统__ ##
### 1. 用户态和内核态区别 ###
(1) CPU有Ring 0 1 2 3四种运行级别，不同级别能够运行不同的指令集合  
(2) 用户态和内核态是操作系统的两种运行级别，内核态运行在Ring 0，用户态运行在Ring 3  
(3) 用户态是普通用户进程运行的特权级别，是最低的特权级别  
(4) 当程序需要进行特权操作时，需要切换到内核态，如操作硬件  
(5) 程序处于用户态时，能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的  
(6) 程序处于内核态时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的  
### 2. 关于poll epoll和select的区别 ###
(1) select，poll，epoll都是IO多路复用的机制  
(2) select通过轮询的方式，有最大连接数的限制  
(3) poll通过轮询的方式，没有最大连接数限制  
(4) epoll通过事件通知的方式，支持水平触发和边缘触发，最大连接数上限高，使用mmap的方式传递消息  
### 3. 水平触发和边缘触发的区别 ###
(1) 水平触发：当可读写事件发生时，如果此次没有把数据一次性全部读写完，会一直通知  
(2) 边缘触发: 当可读写事件发生时，如果此次没有把数据一次性全部读写完，不会重复通知，直到有下一次事件发生  
### 3. 进程间通信方式 ###
(1) 信号  
(2) 管道和命名管道，普通管道只能在父子进程或者兄弟进程中使用  
(3) 消息队列  
(4) socket  
(5) 信号量  
(6) 共享内存  
### 4. 进程线程区别 ###
(1) 进程是操作系统资源分配的基本单位  
(2) 线程是任务调度和执行的基本单位  
(3) 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线  
(4) 进程之间相互独立，同一进程下的各个线程之间共享程序的内存空间及资源  
(5) 线程上下文切换比进程上下文切换要快得多  
(6) 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC  
### 5. 线程切换过程 ###
(1) 切出：一个线程被剥夺处理器的使用权而被暂停运行，操作系统会将线程的进度信息保存到内存  
(2) 切入：一个线程被系统选中占用处理器开始或继续运行，操作系统需要从内存中加载线程的上下文  
### 6. 什么是僵尸进程 ###
(1) 进程已经退出，而其父进程并没有调用 wait() 或 waitpid()，那么该进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程  
(2) 僵尸进程通过 ps 命令显示出来的状态为 Z(zombie)  
(3) 大量僵尸进程将占用大量PID导致系统不能产生新的进程  
(4) 消灭僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而可以被init进程结束  
### 7. 什么是孤儿进程 ###
(1) 进程的父进程退出，但还在运行的进程  
(2) 孤儿进程会被init进程接管，所以孤儿进程不会对系统造成危害  
### 8. 死锁的必要条件 ###
(1) 互斥：每个资源要么已经分配给了一个进程，要么就是可用的  
(2) 占有和等待：已经得到了某个资源的进程可以再请求新的资源  
(3) 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放  
(4) 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源  
### 9. 死锁检测 ###
(1) 检测环路  
### 10. 死锁恢复 ###
(1) 利用抢占恢复  
(2) 利用回滚恢复  
(3) 通过杀死进程恢复  
### 11. 死锁预防 ###
(1) 破坏互斥条件：例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程  
(2) 破坏占有和等待条件  
(3) 破坏不可抢占条件  
(4) 破坏环路等待：给资源统一编号，进程只能按编号顺序来请求资源  
### 12. 死锁避免 ###
(1) 安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的  
(2) 银行家算法  
### 13. 虚拟内存 ###
(1) 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存  
(2) 分页系统地址映射：内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表  
(3) 页面置换算法：1.最佳 2.最近最久未使用 3.最近未使用 4.先进先出 5.第二次机会算法 6.时钟  
(4) 分页和分段：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能  
(5) 分页与分段的比较  
* 对程序员的透明性：分页透明，但是分段需要程序显式划分每个段
* 地址空间的维度：分页是一维地址空间，分段是二维的
* 大小是否可以改变：页的大小不可变，段的大小可以动态改变
* 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护
### 14. 机械硬盘调度算法 ###
(1) 先来先服务：按照磁盘请求的顺序进行调度。优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长  
(2) 最短寻道时间优先：优先调度与当前磁头所在磁道距离最近的磁道。虽然平均寻道时间比较低，但是不够公平。两端的磁道请求更容易出现饥饿现象  
(3) 电梯（扫描）算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向  
